import google.generativeai as genai
from typing import Dict, Any
import os
from datetime import datetime

class RequirementsAI:
    """
    Requirements AI Persona - Analyzes product requirements and generates
    comprehensive feature requirements documentation.
    """
    
    def __init__(self):
        api_key = os.getenv('GEMINI_API_KEY')
        if not api_key:
            raise ValueError("GEMINI_API_KEY environment variable not set")
        genai.configure(api_key=api_key)
        # Use Gemini 2.5 Flash - stable and fast
        self.model = genai.GenerativeModel('models/gemini-2.5-flash')
        self.fallback_model = genai.GenerativeModel('models/gemini-1.5-flash')  # Lighter fallback
        self.persona_version = "v1.0.0"
        
    def analyze_requirements(self, input_doc: str, context: Dict[str, Any] = None) -> str:
        """
        Analyze input requirements and generate FEATURE_REQUIREMENTS.md
        
        Args:
            input_doc: Raw requirements document (markdown)
            context: Optional context about the project (architecture, coding standards)
        
        Returns:
            Formatted FEATURE_REQUIREMENTS.md content
        """
        
        prompt = f"""
You are a Requirements AI persona (v{self.persona_version}) - an expert Business Analyst and Requirements Engineer.

Your task is to analyze the following product requirement document and generate a comprehensive 
FEATURE_REQUIREMENTS.md file following this structure:

## Required Sections:
1. **Executive Summary & Scope**
   - Feature name and business objective
   - Business impact assessment
   - Technical scope (Frontend/Backend/Full-Stack)

2. **User Flow Analysis**
   - Primary user flows (step-by-step)
   - Secondary user flows
   - Edge cases and error scenarios

3. **Functional Requirements**
   - Frontend requirements (FR-1, FR-2, etc.)
   - Backend requirements (BR-1, BR-2, etc.)
   - Integration requirements (IR-1, IR-2, etc.)

4. **Non-Functional Requirements**
   - Performance requirements
   - Security requirements
   - Accessibility requirements

5. **Acceptance Criteria**
   - Primary acceptance criteria (AC-1, AC-2, etc.)
   - Technical acceptance criteria (TAC-1, TAC-2, etc.)

6. **Success Metrics**
   - Measurable success criteria
   - Testing requirements

## Context:
{f"Project Context: {context}" if context else "No additional context provided"}

## Input Requirements Document:
{input_doc}

Generate a detailed, professional FEATURE_REQUIREMENTS.md document.
Use markdown formatting with proper headers, lists, and code blocks where appropriate.
Be specific and actionable - avoid vague requirements.
Keep the response focused and concise.
"""

        # Configure generation settings
        generation_config = {
            'temperature': 0.7,
            'top_p': 0.95,
            'top_k': 40,
            'max_output_tokens': 4096,
        }

        # Try primary model, fallback to lighter model if overloaded
        try:
            response = self.model.generate_content(
                prompt,
                generation_config=generation_config
            )
        except Exception as e:
            error_str = str(e).lower()
            if "503" in str(e) or "overloaded" in error_str or "unavailable" in error_str:
                print("   ⚠️  Primary model overloaded, trying fallback model (gemini-1.5-flash)...")
                response = self.fallback_model.generate_content(
                    prompt,
                    generation_config=generation_config
                )
            else:
                raise

        # Handle multi-part responses
        try:
            output = response.text.strip()
        except ValueError:
            # Response has multiple parts, concatenate them
            output = ""
            for candidate in response.candidates:
                for part in candidate.content.parts:
                    if hasattr(part, 'text'):
                        output += part.text
            output = output.strip()

        # Strip markdown code fences if present
        if output.startswith('```markdown'):
            output = output[len('```markdown'):].strip()
        if output.startswith('```'):
            output = output[3:].strip()
        if output.endswith('```'):
            output = output[:-3].strip()

        # Add AI generation footprint
        output += f"\n\n---\n\n## AI Generation Footprint\n\n"
        output += f"**Generated By**: Requirements AI\n\n"
        output += f"**Framework Version**: {self.persona_version}\n\n"
        output += f"**Generation Date**: {datetime.utcnow().isoformat()} UTC\n\n"
        output += f"**Review Status**: PENDING_REVIEW\n\n"
        output += f"---\n\n"
        output += f"Co-authored by Requirements AI using Persona-Driven AI Framework {self.persona_version}\n"
        
        return output
    
    def validate_output(self, output: str) -> Dict[str, Any]:
        """Validate that generated requirements meet quality standards"""
        output_lower = output.lower()

        validation = {
            "has_executive_summary": "executive summary" in output_lower or "scope" in output_lower,
            "has_user_flows": "user flow" in output_lower or "user journey" in output_lower,
            "has_functional_requirements": "functional requirement" in output_lower or "requirements" in output_lower,
            "has_acceptance_criteria": "acceptance criteria" in output_lower or "success criteria" in output_lower,
            "has_ai_footprint": "AI Generation Footprint" in output,
            "word_count": len(output.split()),
        }
        validation["is_valid"] = all([
            validation["has_executive_summary"],
            validation["has_functional_requirements"],
            validation["word_count"] > 200  # Reduced from 500 to be more lenient
        ])
        return validation

